<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Julia Set Explorer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #0a0a0f;
  --panel-bg: #0d0d1a;
  --accent: #1a0a2e;
  --highlight: #e94560;
  --text: #eee;
  --text-dim: #aaa;
  --border: #2a1a3a;
  --panel-width: 300px;
  --neon-pink: #ff00ff;
  --neon-cyan: #00ffff;
  --neon-green: #39ff14;
  --neon-yellow: #ffff00;
  --neon-blue: #4444ff;
}

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

/* Header */
#header {
  height: 40px;
  background: linear-gradient(90deg, #0d0d1a, #1a0a2e, #0d0d1a);
  display: flex;
  align-items: center;
  padding: 0 12px;
  border-bottom: 1px solid var(--neon-pink);
  box-shadow: 0 2px 12px rgba(255, 0, 255, 0.3);
  z-index: 100;
  position: relative;
}

#header h1 {
  font-size: 16px;
  font-weight: 600;
  margin-left: 8px;
  flex: 1;
  background: linear-gradient(90deg, var(--neon-pink), var(--neon-cyan), var(--neon-green), var(--neon-yellow), var(--neon-pink));
  background-size: 300% 100%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: raveTitle 4s linear infinite;
}

@keyframes raveTitle {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}

.header-btn {
  background: none;
  border: 1px solid transparent;
  color: var(--neon-cyan);
  font-size: 18px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  transition: all 0.3s;
  text-shadow: 0 0 8px var(--neon-cyan);
}

.header-btn:hover {
  background: rgba(0, 255, 255, 0.1);
  border-color: var(--neon-cyan);
  box-shadow: 0 0 12px rgba(0, 255, 255, 0.4);
}

/* Layout */
#app {
  display: flex;
  height: calc(100vh - 40px);
}

/* Controls Panel */
#controls {
  width: var(--panel-width);
  min-width: var(--panel-width);
  background: linear-gradient(180deg, #0d0d1a 0%, #120826 30%, #0d0d1a 60%, #0a1628 100%);
  border-right: 1px solid;
  border-image: linear-gradient(180deg, var(--neon-pink), var(--neon-cyan), var(--neon-green), var(--neon-pink)) 1;
  overflow-y: auto;
  overflow-x: hidden;
  transition: margin-left 0.3s ease, opacity 0.3s ease;
  scrollbar-width: thin;
  scrollbar-color: var(--neon-pink) transparent;
  position: relative;
}

#controls::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background:
    radial-gradient(ellipse at 20% 20%, rgba(255, 0, 255, 0.06) 0%, transparent 60%),
    radial-gradient(ellipse at 80% 60%, rgba(0, 255, 255, 0.06) 0%, transparent 60%),
    radial-gradient(ellipse at 40% 90%, rgba(57, 255, 20, 0.04) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
  animation: raveGlow 6s ease-in-out infinite alternate;
}

@keyframes raveGlow {
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}

#controls > * { position: relative; z-index: 1; }

#controls.collapsed {
  margin-left: calc(-1 * var(--panel-width));
  opacity: 0;
  pointer-events: none;
}

#controls::-webkit-scrollbar { width: 6px; }
#controls::-webkit-scrollbar-track { background: transparent; }
#controls::-webkit-scrollbar-thumb { background: var(--neon-pink); border-radius: 3px; box-shadow: 0 0 6px var(--neon-pink); }

.section {
  padding: 12px;
  border-bottom: 1px solid rgba(255, 0, 255, 0.2);
}

.section-title {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 10px;
  font-weight: 700;
  animation: neonPulse 3s ease-in-out infinite;
  text-shadow: 0 0 6px currentColor;
}

.section:nth-child(1) .section-title { color: var(--neon-pink); }
.section:nth-child(2) .section-title { color: var(--neon-cyan); animation-delay: 0.4s; }
.section:nth-child(3) .section-title { color: var(--neon-green); animation-delay: 0.8s; }
.section:nth-child(4) .section-title { color: var(--neon-yellow); animation-delay: 1.2s; }
.section:nth-child(5) .section-title { color: var(--neon-pink); animation-delay: 1.6s; }
.section:nth-child(6) .section-title { color: var(--neon-cyan); animation-delay: 2.0s; }
.section:nth-child(7) .section-title { color: var(--neon-green); animation-delay: 2.4s; }
.section:nth-child(8) .section-title { color: var(--neon-yellow); animation-delay: 2.8s; }

@keyframes neonPulse {
  0%, 100% { text-shadow: 0 0 4px currentColor, 0 0 8px currentColor; opacity: 0.9; }
  50% { text-shadow: 0 0 8px currentColor, 0 0 20px currentColor, 0 0 40px currentColor; opacity: 1; }
}

/* Controls Styling */
label {
  display: block;
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 4px;
}

.slider-row {
  margin-bottom: 10px;
}

.slider-row .value {
  font-size: 12px;
  color: var(--neon-cyan);
  font-weight: 600;
  float: right;
  text-shadow: 0 0 6px var(--neon-cyan);
}

input[type="range"] {
  width: 100%;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: linear-gradient(90deg, var(--neon-pink), var(--neon-cyan), var(--neon-green));
  border-radius: 2px;
  outline: none;
  margin: 6px 0;
  box-shadow: 0 0 6px rgba(255, 0, 255, 0.3);
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--neon-pink);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 8px var(--neon-pink), 0 0 16px var(--neon-pink);
  transition: box-shadow 0.2s;
}

input[type="range"]::-webkit-slider-thumb:hover {
  box-shadow: 0 0 12px var(--neon-pink), 0 0 24px var(--neon-pink), 0 0 36px var(--neon-pink);
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: var(--neon-pink);
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 0 8px var(--neon-pink), 0 0 16px var(--neon-pink);
}

select {
  width: 100%;
  padding: 6px 8px;
  background: rgba(26, 10, 46, 0.8);
  color: var(--neon-cyan);
  border: 1px solid var(--neon-pink);
  border-radius: 4px;
  font-size: 13px;
  cursor: pointer;
  box-shadow: 0 0 6px rgba(255, 0, 255, 0.2), inset 0 0 6px rgba(0, 255, 255, 0.1);
  text-shadow: 0 0 4px var(--neon-cyan);
}

/* Radio buttons */
.radio-group { margin-bottom: 8px; }

.radio-group label {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  cursor: pointer;
  color: var(--text);
  font-size: 13px;
}

input[type="radio"] { accent-color: var(--neon-pink); }

/* Buttons */
.btn {
  padding: 6px 12px;
  background: rgba(26, 10, 46, 0.6);
  color: var(--neon-cyan);
  border: 1px solid var(--neon-pink);
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.3s;
  text-shadow: 0 0 4px var(--neon-cyan);
  box-shadow: 0 0 4px rgba(255, 0, 255, 0.2);
}

.btn:hover {
  background: rgba(255, 0, 255, 0.2);
  box-shadow: 0 0 12px var(--neon-pink), 0 0 24px rgba(255, 0, 255, 0.3);
  text-shadow: 0 0 8px var(--neon-cyan);
}

.btn-row {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 6px;
}

.preset-btn {
  padding: 4px 10px;
  background: rgba(26, 10, 46, 0.6);
  color: var(--neon-green);
  border: 1px solid var(--neon-green);
  border-radius: 12px;
  cursor: pointer;
  font-size: 11px;
  transition: all 0.3s;
  text-shadow: 0 0 4px var(--neon-green);
  box-shadow: 0 0 4px rgba(57, 255, 20, 0.15);
}

.preset-btn:hover, .preset-btn.active {
  background: rgba(57, 255, 20, 0.15);
  border-color: var(--neon-green);
  box-shadow: 0 0 10px var(--neon-green), 0 0 20px rgba(57, 255, 20, 0.3);
}

/* Checkboxes */
.checkbox-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin: 6px 0;
  font-size: 13px;
}

input[type="checkbox"] { accent-color: var(--neon-pink); }

/* Canvas Area */
#canvas-container {
  flex: 1;
  position: relative;
  overflow: hidden;
  cursor: crosshair;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Overlays */
.overlay {
  position: absolute;
  background: rgba(22, 33, 62, 0.85);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 11px;
  pointer-events: none;
  font-family: 'Courier New', monospace;
}

#coords-overlay {
  top: 8px;
  right: 8px;
}

#zoom-overlay {
  bottom: 8px;
  right: 8px;
}

#info-overlay {
  bottom: 8px;
  left: 8px;
}

/* Loading spinner */
#loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;
}

#loading .spinner {
  width: 30px;
  height: 30px;
  border: 3px solid var(--accent);
  border-top-color: var(--highlight);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* Info panel */
#info-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 500px;
  max-width: 90vw;
  max-height: 80vh;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  overflow-y: auto;
  display: none;
  z-index: 200;
}

#info-panel.visible { display: block; }

#info-panel h2 { color: var(--highlight); margin-bottom: 12px; font-size: 18px; }
#info-panel h3 { color: var(--highlight); margin: 12px 0 6px; font-size: 14px; }
#info-panel p { font-size: 13px; line-height: 1.5; margin-bottom: 8px; color: var(--text-dim); }
#info-panel code { background: var(--accent); padding: 1px 4px; border-radius: 2px; font-size: 12px; }
#info-panel .close-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  color: var(--text);
  font-size: 20px;
  cursor: pointer;
}

#info-panel kbd {
  background: var(--accent);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 11px;
  border: 1px solid var(--border);
}

/* Orbit overlay */
#orbit-panel {
  position: absolute;
  top: 8px;
  left: 8px;
  background: rgba(22, 33, 62, 0.9);
  padding: 10px;
  border-radius: 6px;
  font-size: 11px;
  display: none;
  max-width: 250px;
  font-family: 'Courier New', monospace;
  border: 1px solid var(--border);
}

#orbit-panel.visible { display: block; }

/* Quiz Modal */
#quiz-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10, 10, 20, 0.92);
  z-index: 500;
  display: none;
  justify-content: center;
  align-items: center;
}

#quiz-overlay.visible { display: flex; }

#quiz-box {
  background: var(--panel-bg);
  border: 2px solid var(--highlight);
  border-radius: 12px;
  padding: 32px;
  width: 520px;
  max-width: 92vw;
  max-height: 85vh;
  overflow-y: auto;
  text-align: center;
  position: relative;
  box-shadow: 0 0 60px rgba(233, 69, 96, 0.3);
}

#quiz-box h2 {
  color: var(--highlight);
  font-size: 20px;
  margin-bottom: 6px;
}

#quiz-box .quiz-subtitle {
  color: var(--text-dim);
  font-size: 13px;
  margin-bottom: 20px;
}

#quiz-box .quiz-question {
  font-size: 15px;
  margin-bottom: 16px;
  line-height: 1.5;
}

#quiz-box .quiz-step {
  color: var(--text-dim);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}

.quiz-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 16px;
}

.quiz-option {
  padding: 10px 16px;
  background: var(--accent);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
}

.quiz-option:hover {
  background: var(--highlight);
  border-color: var(--highlight);
  transform: translateX(4px);
}

.quiz-option.correct {
  background: #1a7a3a;
  border-color: #2ecc71;
}

.quiz-option.wrong {
  background: #7a1a1a;
  border-color: #e74c3c;
}

#quiz-result {
  font-size: 14px;
  margin-top: 12px;
  min-height: 24px;
}

.quiz-restart-msg {
  color: var(--highlight);
  font-size: 18px;
  font-weight: 600;
  animation: quizShake 0.5s ease;
}

@keyframes quizShake {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-10px); }
  40% { transform: translateX(10px); }
  60% { transform: translateX(-6px); }
  80% { transform: translateX(6px); }
}

.quiz-personality {
  margin-top: 16px;
  padding: 16px;
  background: var(--accent);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.quiz-personality h3 {
  color: var(--highlight);
  font-size: 16px;
  margin-bottom: 8px;
}

.quiz-personality p {
  font-size: 13px;
  color: var(--text-dim);
  line-height: 1.5;
}

.quiz-close-btn {
  margin-top: 16px;
  padding: 8px 24px;
  background: var(--highlight);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: opacity 0.2s;
}

.quiz-close-btn:hover { opacity: 0.8; }

/* Responsive */
@media (max-width: 768px) {
  :root { --panel-width: 260px; }
  #header h1 { font-size: 14px; }
}
</style>
</head>
<body>

<div id="header">
  <button class="header-btn" id="toggle-controls" title="Toggle Controls (Space)">&#9776;</button>
  <h1>Julia Set Explorer</h1>
  <button class="header-btn" id="quiz-btn" title="Fractal Personality Quiz">&#10070;</button>
  <button class="header-btn" id="info-btn" title="Info (I)">&#9432;</button>
</div>

<div id="app">
  <div id="controls">

    <!-- Fractal Type -->
    <div class="section">
      <div class="section-title">Fractal Type</div>
      <div class="radio-group">
        <label><input type="radio" name="fractalType" value="julia" checked> Julia Set</label>
        <label><input type="radio" name="fractalType" value="mandelbrot"> Mandelbrot Set</label>
        <label><input type="radio" name="fractalType" value="burningship"> Burning Ship</label>
        <label><input type="radio" name="fractalType" value="split"> Split View</label>
      </div>
    </div>

    <!-- Julia Parameters -->
    <div class="section" id="julia-params">
      <div class="section-title">Julia Parameters (c = a + bi)</div>
      <div class="slider-row">
        <label>Real Part (a): <span class="value" id="real-val">-0.70</span></label>
        <input type="range" id="real-slider" min="-2" max="2" step="0.001" value="-0.7">
      </div>
      <div class="slider-row">
        <label>Imaginary Part (b): <span class="value" id="imag-val">0.27</span></label>
        <input type="range" id="imag-slider" min="-2" max="2" step="0.001" value="0.27">
      </div>
    </div>

    <!-- Presets -->
    <div class="section" id="presets-section">
      <div class="section-title">Famous Julia Sets</div>
      <div class="btn-row">
        <button class="preset-btn" data-real="0" data-imag="1">Dendrite</button>
        <button class="preset-btn" data-real="-0.75" data-imag="0.11">Spiral</button>
        <button class="preset-btn" data-real="-0.123" data-imag="0.745">Douady Rabbit</button>
        <button class="preset-btn" data-real="-0.75" data-imag="0">San Marco</button>
        <button class="preset-btn" data-real="-0.8" data-imag="0.156">Dragon</button>
        <button class="preset-btn" data-real="-0.390541" data-imag="-0.586788">Siegel Disk</button>
        <button class="preset-btn" id="random-preset">Random</button>
      </div>
    </div>

    <!-- Color Scheme -->
    <div class="section">
      <div class="section-title">Color Scheme</div>
      <select id="color-scheme">
        <option value="classic">Classic</option>
        <option value="fire">Fire</option>
        <option value="ocean" selected>Ocean</option>
        <option value="electric">Electric</option>
        <option value="grayscale">Grayscale</option>
        <option value="rainbow">Rainbow</option>
      </select>
    </div>

    <!-- Rendering Options -->
    <div class="section">
      <div class="section-title">Rendering</div>
      <div class="slider-row">
        <label>Max Iterations: <span class="value" id="iter-val">300</span></label>
        <input type="range" id="iter-slider" min="50" max="2000" step="10" value="300">
      </div>
      <div class="slider-row">
        <label>Escape Radius: <span class="value" id="escape-val">4</span></label>
        <input type="range" id="escape-slider" min="2" max="20" step="0.5" value="4">
      </div>
      <div class="checkbox-row">
        <input type="checkbox" id="smooth-check" checked>
        <label for="smooth-check">Smooth coloring</label>
      </div>
    </div>

    <!-- View Controls -->
    <div class="section">
      <div class="section-title">View Controls</div>
      <div class="btn-row">
        <button class="btn" id="zoom-in-btn">Zoom In</button>
        <button class="btn" id="zoom-out-btn">Zoom Out</button>
        <button class="btn" id="reset-view-btn">Reset View</button>
      </div>
      <div class="checkbox-row" style="margin-top:8px">
        <input type="checkbox" id="show-coords" checked>
        <label for="show-coords">Show coordinates</label>
      </div>
      <div class="checkbox-row">
        <input type="checkbox" id="show-orbit">
        <label for="show-orbit">Show orbit on click</label>
      </div>
    </div>

    <!-- Animation -->
    <div class="section" id="anim-section">
      <div class="section-title">Animation</div>
      <div class="btn-row">
        <button class="btn" id="anim-play">&#9654; Play</button>
        <button class="btn" id="anim-pause">&#9208; Pause</button>
        <button class="btn" id="anim-stop">&#9209; Stop</button>
      </div>
      <div class="slider-row" style="margin-top:8px">
        <label>Speed: <span class="value" id="speed-val">0.50</span></label>
        <input type="range" id="speed-slider" min="0.05" max="2" step="0.05" value="0.5">
      </div>
      <div class="radio-group" style="margin-top:6px">
        <label><input type="radio" name="animPath" value="circle" checked> Circle</label>
        <label><input type="radio" name="animPath" value="figure8"> Figure-8</label>
      </div>
    </div>

    <!-- Export -->
    <div class="section">
      <div class="section-title">Export</div>
      <div class="btn-row">
        <button class="btn" id="save-btn">Save Image (PNG)</button>
        <button class="btn" id="copy-params-btn">Copy Parameters</button>
      </div>
    </div>

  </div>

  <!-- Canvas -->
  <div id="canvas-container">
    <canvas id="fractal-canvas"></canvas>
    <!-- Split view canvas (hidden by default) -->
    <canvas id="split-canvas" style="display:none; position:absolute; top:0; left:0; width:50%; height:100%;"></canvas>
    <div class="overlay" id="coords-overlay">Move mouse over canvas</div>
    <div class="overlay" id="zoom-overlay">Zoom: 1.00x</div>
    <div class="overlay" id="info-overlay" style="display:none"></div>
    <div id="loading"><div class="spinner"></div></div>
    <div id="orbit-panel"></div>
  </div>
</div>

<!-- Info Panel -->
<div id="info-panel">
  <button class="close-btn" id="close-info">&times;</button>
  <h2>Julia Set Explorer</h2>
  <h3>What are Julia Sets?</h3>
  <p>For a complex constant <code>c</code>, the Julia set is the boundary of points <code>z</code> where the iteration <code>z = z&sup2; + c</code> remains bounded. Points that escape to infinity are colored based on how quickly they escape.</p>
  <h3>The Mandelbrot Connection</h3>
  <p>The Mandelbrot set is the "map" of all Julia sets. Each point <code>c</code> in the Mandelbrot set corresponds to a connected Julia set. Use Split View to explore this relationship interactively!</p>
  <h3>Keyboard Shortcuts</h3>
  <p>
    <kbd>Space</kbd> Toggle controls &nbsp;
    <kbd>R</kbd> Reset view &nbsp;
    <kbd>S</kbd> Save image &nbsp;
    <kbd>A</kbd> Toggle animation &nbsp;
    <kbd>I</kbd> Toggle info &nbsp;
    <kbd>+/-</kbd> Zoom &nbsp;
    <kbd>Arrows</kbd> Pan &nbsp;
    <kbd>1-6</kbd> Presets
  </p>
  <h3>Mouse Controls</h3>
  <p>
    <strong>Drag</strong> to pan &bull;
    <strong>Scroll</strong> to zoom &bull;
    <strong>Double-click</strong> to zoom in 2x &bull;
    <strong>Click</strong> (with orbit on) to see iteration path
  </p>
</div>

<!-- Quiz Overlay -->
<div id="quiz-overlay">
  <div id="quiz-box">
    <div id="quiz-content"></div>
  </div>
</div>

<script>
// ==================== FRACTAL PERSONALITY QUIZ ====================
const quizData = {
  currentStep: 0,
  answers: [],
  correctDifficultyIndex: 0,

  questions: [
    {
      question: "When you close your eyes and think about infinity, what do you see?",
      options: [
        "A never-ending spiral staircase going down",
        "Turtles. All the way down.",
        "My browser tabs",
        "A fractal, obviously. That's why I'm here."
      ]
    },
    {
      question: "A complex number walks into a bar. The bartender says, \"We don't serve your kind here.\" The complex number replies:",
      options: [
        "\"But I'm REAL... partly.\"",
        "\"You can't handle my imaginary side.\"",
        "\"I'll just rotate 90 degrees and become real.\"",
        "*silently iterates until escaping to infinity*"
      ]
    },
    {
      question: "What's your preferred method of relaxation?",
      options: [
        "Zooming into fractals until I question reality",
        "Calculating escape velocities by hand",
        "Arguing about whether 0.999... equals 1",
        "Watching paint dry (it forms fractal patterns if you look close enough)"
      ]
    },
    {
      question: "If you were a fractal, what would be your escape radius?",
      options: [
        "2 - I'm a classicist",
        "Infinity - I never escape, I'm part of the set",
        "I don't believe in boundaries",
        "Whatever gets me out of this quiz fastest"
      ]
    },
    {
      // This is the trick question - dynamically built
      type: 'difficulty',
      question: "How easy was it to get access to this website?",
      // Options are in different languages, correct answer randomizes
      allOptions: [
        { label: "Muy dificil", lang: "Spanish", meaning: "Very difficult" },
        { label: "Difficile", lang: "Italian", meaning: "Difficult" },
        { label: "Neutraali", lang: "Finnish", meaning: "Neutral" },
        { label: "Kolay", lang: "Turkish", meaning: "Easy" },
        { label: "Rất dễ dàng", lang: "Vietnamese", meaning: "Very easy" }
      ]
    }
  ],

  personalities: [
    {
      name: "The Dendrite Dreamer",
      desc: "You exist on the boundary between order and chaos. Your Julia set is connected but just barely - one wrong parameter and you dissolve into Cantor dust. You probably also leave 47 browser tabs open.",
      preset: { real: 0, imag: 1 }
    },
    {
      name: "The Spiral Sage",
      desc: "You see patterns within patterns within patterns. People think you're zoning out but really you're computing Fibonacci sequences in your head. Your ideal date is at a zoom level of 10^14.",
      preset: { real: -0.75, imag: 0.11 }
    },
    {
      name: "The Douady Rabbit Enthusiast",
      desc: "Three-fold symmetry speaks to your soul. You see rabbits in clouds, rabbits in fractals, rabbits everywhere. Gaston Julia would be proud. Or concerned.",
      preset: { real: -0.123, imag: 0.745 }
    },
    {
      name: "The Burning Ship Captain",
      desc: "You chose chaos. While others gently iterate z = z² + c, you take absolute values and watch the world burn. Your browser history is 90% fractal zoom videos.",
      preset: { real: -0.8, imag: 0.156 }
    }
  ]
};

function startQuiz() {
  quizData.currentStep = 0;
  quizData.answers = [];
  // Randomize which difficulty option is "correct"
  quizData.correctDifficultyIndex = Math.floor(Math.random() * 5);
  document.getElementById('quiz-overlay').classList.add('visible');
  renderQuizStep();
}

function renderQuizStep() {
  const content = document.getElementById('quiz-content');
  const step = quizData.currentStep;
  const total = quizData.questions.length;

  if (step >= total) {
    showQuizResult();
    return;
  }

  const q = quizData.questions[step];

  let optionsHTML = '';

  if (q.type === 'difficulty') {
    // Shuffle the options order for display but track correctness
    const shuffled = [...q.allOptions].sort(() => Math.random() - 0.5);
    const correctMeaning = q.allOptions[quizData.correctDifficultyIndex].meaning;

    optionsHTML = shuffled.map((opt, i) => {
      const isCorrect = opt.meaning === correctMeaning;
      return `<button class="quiz-option" data-correct="${isCorrect}" data-lang="${opt.lang}" data-meaning="${opt.meaning}" onclick="handleDifficultyAnswer(this)">${opt.label}</button>`;
    }).join('');

    content.innerHTML = `
      <h2>Fractal Personality Quiz</h2>
      <div class="quiz-step">Question ${step + 1} of ${total}</div>
      <div class="quiz-question">${q.question}</div>
      <div class="quiz-options">${optionsHTML}</div>
      <div id="quiz-result"></div>
    `;
  } else {
    optionsHTML = q.options.map((opt, i) =>
      `<button class="quiz-option" onclick="handleQuizAnswer(${i})">${opt}</button>`
    ).join('');

    content.innerHTML = `
      <h2>Fractal Personality Quiz</h2>
      <div class="quiz-subtitle">${step === 0 ? 'Discover your inner fractal identity' : ''}</div>
      <div class="quiz-step">Question ${step + 1} of ${total}</div>
      <div class="quiz-question">${q.question}</div>
      <div class="quiz-options">${optionsHTML}</div>
    `;
  }
}

function handleQuizAnswer(index) {
  quizData.answers.push(index);
  quizData.currentStep++;
  renderQuizStep();
}

function handleDifficultyAnswer(btn) {
  const isCorrect = btn.dataset.correct === 'true';
  const lang = btn.dataset.lang;
  const meaning = btn.dataset.meaning;
  const resultDiv = document.getElementById('quiz-result');

  // Disable all buttons
  document.querySelectorAll('.quiz-option').forEach(b => {
    b.style.pointerEvents = 'none';
  });

  if (isCorrect) {
    btn.classList.add('correct');
    resultDiv.innerHTML = `<span style="color:#2ecc71">Correct! That was ${lang} for "${meaning}"</span>`;
    quizData.answers.push('correct');
    setTimeout(() => {
      quizData.currentStep++;
      renderQuizStep();
    }, 1200);
  } else {
    btn.classList.add('wrong');

    // Find and highlight the correct one
    document.querySelectorAll('.quiz-option').forEach(b => {
      if (b.dataset.correct === 'true') b.classList.add('correct');
    });

    resultDiv.innerHTML = `<div class="quiz-restart-msg">WRONG! That was ${lang} for "${meaning}".<br>Back to the beginning...</div>`;

    setTimeout(() => {
      quizData.currentStep = 0;
      quizData.answers = [];
      // Re-randomize the correct answer
      quizData.correctDifficultyIndex = Math.floor(Math.random() * 5);
      renderQuizStep();
    }, 2200);
  }
}

function showQuizResult() {
  const content = document.getElementById('quiz-content');
  // Pick personality based on sum of answer indices
  const sum = quizData.answers.reduce((a, b) => typeof b === 'number' ? a + b : a, 0);
  const personality = quizData.personalities[sum % quizData.personalities.length];

  // Set the fractal to match personality
  state.c.real = personality.preset.real;
  state.c.imag = personality.preset.imag;
  updateSliders();
  queueRender();

  content.innerHTML = `
    <h2>Quiz Complete!</h2>
    <div class="quiz-personality">
      <h3>You are: ${personality.name}</h3>
      <p>${personality.desc}</p>
    </div>
    <p style="margin-top:12px; color:var(--text-dim); font-size:12px;">Your fractal has been set to match your personality.</p>
    <button class="quiz-close-btn" onclick="closeQuiz()">Explore My Fractal</button>
    <br>
    <button class="quiz-close-btn" style="background:var(--accent); margin-top:8px;" onclick="startQuiz()">Retake Quiz</button>
  `;
}

function closeQuiz() {
  document.getElementById('quiz-overlay').classList.remove('visible');
}

// ==================== STATE ====================
const state = {
  fractalType: 'julia',
  c: { real: -0.7, imag: 0.27 },
  maxIter: 300,
  escapeRadius: 4,
  smooth: true,
  colorScheme: 'ocean',
  // View
  centerX: 0,
  centerY: 0,
  zoom: 1,
  // Animation
  animating: false,
  animT: 0,
  animSpeed: 0.5,
  animPath: 'circle',
  // UI
  showCoords: true,
  showOrbit: false,
  controlsVisible: true,
  // Drag
  dragging: false,
  dragStartX: 0,
  dragStartY: 0,
  dragCenterX: 0,
  dragCenterY: 0,
};

// ==================== CANVAS SETUP ====================
const canvas = document.getElementById('fractal-canvas');
const ctx = canvas.getContext('2d');
const splitCanvas = document.getElementById('split-canvas');
const splitCtx = splitCanvas.getContext('2d');
let imageData, pixels;
let splitImageData, splitPixels;
let renderQueued = false;
let interacting = false;
let fullResTimeout = null;
const DRAFT_SCALE = 0.35; // render at 35% during interaction

// Web Worker for offloading fractal computation
const workerCode = `
self.onmessage = function(e) {
  const { id, w, h, yStart, fullH, fractalType, cr, ci, centerX, centerY, zoom, maxIter, escapeRadius, smooth, colorScheme } = e.data;
  const buf = new ArrayBuffer(w * h * 4);
  const pixels = new Uint8ClampedArray(buf);
  const minDim = Math.min(w, fullH);
  const scale = 3 / (minDim * zoom);
  const halfW = w / 2;
  const halfH = fullH / 2;
  const escR2 = escapeRadius * escapeRadius;
  const log2 = Math.log(2);

  // Color scheme LUT (256 entries)
  const lut = new Uint8Array(768);
  for (let n = 0; n < 256; n++) {
    const t = n / 255;
    let r, g, b;
    switch (colorScheme) {
      case 'classic':
        if (t < 0.25) { const s = t / 0.25; r = 0; g = s * 128; b = 128 + s * 127; }
        else if (t < 0.5) { const s = (t - 0.25) / 0.25; r = s * 255; g = 128 + s * 127; b = 255 - s * 128; }
        else if (t < 0.75) { const s = (t - 0.5) / 0.25; r = 255; g = 255 - s * 128; b = 127 - s * 127; }
        else { const s = (t - 0.75) / 0.25; r = 255 - s * 200; g = 127 - s * 127; b = 0; }
        break;
      case 'fire':
        if (t < 0.33) { const s = t / 0.33; r = s * 200; g = 0; b = 0; }
        else if (t < 0.66) { const s = (t - 0.33) / 0.33; r = 200 + s * 55; g = s * 165; b = 0; }
        else { const s = (t - 0.66) / 0.34; r = 255; g = 165 + s * 90; b = s * 200; }
        break;
      case 'ocean':
        if (t < 0.33) { const s = t / 0.33; r = 0; g = s * 100; b = 80 + s * 120; }
        else if (t < 0.66) { const s = (t - 0.33) / 0.33; r = 0; g = 100 + s * 155; b = 200 + s * 55; }
        else { const s = (t - 0.66) / 0.34; r = s * 180; g = 255; b = 255; }
        break;
      case 'electric':
        if (t < 0.25) { const s = t / 0.25; r = 80 + s * 80; g = 0; b = 160 + s * 95; }
        else if (t < 0.5) { const s = (t - 0.25) / 0.25; r = 160 - s * 160; g = s * 100; b = 255; }
        else if (t < 0.75) { const s = (t - 0.5) / 0.25; r = 0; g = 100 + s * 155; b = 255 - s * 55; }
        else { const s = (t - 0.75) / 0.25; r = s * 255; g = 255; b = 200 - s * 100; }
        break;
      case 'grayscale':
        r = g = b = t * 255; break;
      case 'rainbow': {
        const hue = t * 360;
        const c2 = 1 - Math.abs((hue / 60) % 2 - 1);
        if (hue < 60) { r = 255; g = c2 * 255; b = 0; }
        else if (hue < 120) { r = c2 * 255; g = 255; b = 0; }
        else if (hue < 180) { r = 0; g = 255; b = c2 * 255; }
        else if (hue < 240) { r = 0; g = c2 * 255; b = 255; }
        else if (hue < 300) { r = c2 * 255; g = 0; b = 255; }
        else { r = 255; g = 0; b = c2 * 255; }
        break;
      }
      default: r = g = b = t * 255;
    }
    lut[n * 3] = r;
    lut[n * 3 + 1] = g;
    lut[n * 3 + 2] = b;
  }

  for (let py = 0; py < h; py++) {
    const cy_px = (py + yStart - halfH) * scale + centerY;
    for (let px = 0; px < w; px++) {
      const cx_px = (px - halfW) * scale + centerX;
      let zr, zi, pcr, pci;
      if (fractalType === 'julia') {
        zr = cx_px; zi = cy_px; pcr = cr; pci = ci;
      } else {
        zr = 0; zi = 0; pcr = cx_px; pci = cy_px;
      }

      let i = 0;
      let zr2 = zr * zr, zi2 = zi * zi;
      if (fractalType === 'burningship') {
        while (i < maxIter && zr2 + zi2 <= escR2) {
          const tmp = zr2 - zi2 + pcr;
          zi = Math.abs(2 * zr * zi) + pci;
          zr = Math.abs(tmp);
          zr2 = zr * zr; zi2 = zi * zi;
          i++;
        }
      } else {
        while (i < maxIter && zr2 + zi2 <= escR2) {
          zi = 2 * zr * zi + pci;
          zr = zr2 - zi2 + pcr;
          zr2 = zr * zr; zi2 = zi * zi;
          i++;
        }
      }

      const idx = (py * w + px) * 4;
      if (i >= maxIter) {
        pixels[idx] = 0; pixels[idx+1] = 0; pixels[idx+2] = 0;
      } else {
        let t;
        if (smooth) {
          const log_zn = Math.log(zr2 + zi2) / 2;
          const nu = Math.log(log_zn / log2) / log2;
          t = ((i + 1 - nu) % 50) / 50;
        } else {
          t = (i % 50) / 50;
        }
        const ci2 = ((t * 255) | 0) * 3;
        pixels[idx] = lut[ci2];
        pixels[idx+1] = lut[ci2+1];
        pixels[idx+2] = lut[ci2+2];
      }
      pixels[idx+3] = 255;
    }
  }

  self.postMessage({ id, buf }, [buf]);
};
`;
const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(workerBlob);
const numWorkers = Math.min(navigator.hardwareConcurrency || 4, 8);
const workers = [];
let workerBusy = new Array(numWorkers).fill(false);
let renderGeneration = 0;

for (let i = 0; i < numWorkers; i++) {
  const w = new Worker(workerUrl);
  w.onmessage = handleWorkerResult;
  workers.push(w);
}

// Track pending tile renders
let pendingTiles = 0;
let expectedTiles = 0;
let currentGeneration = 0;
const tileMap = new Map();
const tileResults = new Map();

function handleWorkerResult(e) {
  const { id, buf } = e.data;
  const gen = id >> 16;
  const tileIdx = id & 0xFFFF;

  // Ignore results from old render generations
  if (gen !== currentGeneration) return;

  const tileInfo = tileMap.get(tileIdx);
  if (!tileInfo) return;

  // Buffer the result instead of painting immediately
  tileResults.set(tileIdx, buf);
  pendingTiles--;

  // Once all tiles for this generation are done, paint them all at once
  if (pendingTiles <= 0) {
    for (const [idx, tileBuf] of tileResults) {
      const info = tileMap.get(idx);
      if (info) {
        const px = new Uint8ClampedArray(tileBuf);
        const imgData = new ImageData(px, info.tw, info.th);
        if (info.draft) {
          // Draft mode: draw to offscreen then scale up
          const off = new OffscreenCanvas(info.tw, info.th);
          const offCtx = off.getContext('2d');
          offCtx.putImageData(imgData, 0, 0);
          info.targetCtx.imageSmoothingEnabled = true;
          info.targetCtx.drawImage(off, 0, info.ty * info.invScale, info.targetCanvas.width, info.th * info.invScale);
        } else {
          info.targetCtx.putImageData(imgData, info.tx, info.ty);
        }
      }
    }
    tileResults.clear();
    tileMap.clear();
  }
}

function resizeCanvas() {
  const container = document.getElementById('canvas-container');

  if (state.fractalType === 'split') {
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.right = '0';
    canvas.style.left = '50%';
    canvas.style.width = '50%';
    canvas.style.height = '100%';
    splitCanvas.style.display = 'block';

    const halfW = Math.floor(container.clientWidth / 2);
    const h = container.clientHeight;

    canvas.width = halfW;
    canvas.height = h;
    splitCanvas.width = halfW;
    splitCanvas.height = h;
    splitCanvas.style.width = halfW + 'px';
    splitCanvas.style.height = h + 'px';

    splitImageData = splitCtx.createImageData(splitCanvas.width, splitCanvas.height);
    splitPixels = splitImageData.data;
  } else {
    canvas.style.position = '';
    canvas.style.left = '';
    canvas.style.right = '';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    splitCanvas.style.display = 'none';

    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
  }

  imageData = ctx.createImageData(canvas.width, canvas.height);
  pixels = imageData.data;
  queueRender();
}

// ==================== COLOR SCHEMES ====================
const colorSchemes = {
  classic(t) {
    // Blue -> Cyan -> Yellow -> Red
    if (t < 0.25) { const s = t / 0.25; return [0, Math.floor(s * 128), Math.floor(128 + s * 127)]; }
    if (t < 0.5) { const s = (t - 0.25) / 0.25; return [Math.floor(s * 255), Math.floor(128 + s * 127), Math.floor(255 - s * 128)]; }
    if (t < 0.75) { const s = (t - 0.5) / 0.25; return [255, Math.floor(255 - s * 128), Math.floor(127 - s * 127)]; }
    const s = (t - 0.75) / 0.25; return [Math.floor(255 - s * 200), Math.floor(127 - s * 127), 0];
  },
  fire(t) {
    if (t < 0.33) { const s = t / 0.33; return [Math.floor(s * 200), 0, 0]; }
    if (t < 0.66) { const s = (t - 0.33) / 0.33; return [200 + Math.floor(s * 55), Math.floor(s * 165), 0]; }
    const s = (t - 0.66) / 0.34; return [255, 165 + Math.floor(s * 90), Math.floor(s * 200)];
  },
  ocean(t) {
    if (t < 0.33) { const s = t / 0.33; return [0, Math.floor(s * 100), Math.floor(80 + s * 120)]; }
    if (t < 0.66) { const s = (t - 0.33) / 0.33; return [0, Math.floor(100 + s * 155), Math.floor(200 + s * 55)]; }
    const s = (t - 0.66) / 0.34; return [Math.floor(s * 180), 255, 255];
  },
  electric(t) {
    if (t < 0.25) { const s = t / 0.25; return [Math.floor(80 + s * 80), 0, Math.floor(160 + s * 95)]; }
    if (t < 0.5) { const s = (t - 0.25) / 0.25; return [Math.floor(160 - s * 160), Math.floor(s * 100), 255]; }
    if (t < 0.75) { const s = (t - 0.5) / 0.25; return [0, Math.floor(100 + s * 155), Math.floor(255 - s * 55)]; }
    const s = (t - 0.75) / 0.25; return [Math.floor(s * 255), 255, Math.floor(200 - s * 100)];
  },
  grayscale(t) {
    const v = Math.floor(t * 255);
    return [v, v, v];
  },
  rainbow(t) {
    const h = t * 360;
    const s = 1, v = 1;
    const c = v * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = v - c;
    let r, g, b;
    if (h < 60) { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    return [Math.floor((r + m) * 255), Math.floor((g + m) * 255), Math.floor((b + m) * 255)];
  }
};

function getColor(iterations, zr, zi, maxIter) {
  if (iterations >= maxIter) return [0, 0, 0];

  let t;
  if (state.smooth) {
    const log_zn = Math.log(zr * zr + zi * zi) / 2;
    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
    const smoothed = iterations + 1 - nu;
    t = (smoothed % 50) / 50;
  } else {
    t = (iterations % 50) / 50;
  }

  return colorSchemes[state.colorScheme](t);
}

// ==================== FRACTAL COMPUTATION ====================
function pixelToComplex(px, py, w, h, cx, cy, zoom) {
  const scale = 3 / (Math.min(w, h) * zoom);
  return {
    x: (px - w / 2) * scale + cx,
    y: (py - h / 2) * scale + cy
  };
}

// ==================== RENDERING (Web Worker tiled) ====================
function dispatchRender(targetCtx, targetCanvas, fractalType, cr, ci, draft) {
  const scale = draft ? DRAFT_SCALE : 1;
  const w = Math.round(targetCanvas.width * scale);
  const h = Math.round(targetCanvas.height * scale);
  const tileH = Math.ceil(h / numWorkers);
  const invScale = 1 / scale;

  for (let i = 0; i < numWorkers; i++) {
    const ty = i * tileH;
    const th = Math.min(tileH, h - ty);
    if (th <= 0) continue;

    const tileIdx = pendingTiles;
    const id = (currentGeneration << 16) | tileIdx;

    tileMap.set(tileIdx, {
      targetCtx, targetCanvas,
      tx: 0, ty, tw: w, th,
      draft, invScale
    });
    pendingTiles++;

    workers[i % numWorkers].postMessage({
      id,
      w, h: th,
      yStart: ty,
      fullH: h,
      fractalType,
      cr, ci,
      centerX: state.centerX,
      centerY: state.centerY,
      zoom: state.zoom,
      maxIter: draft ? Math.min(state.maxIter, 150) : state.maxIter,
      escapeRadius: state.escapeRadius,
      smooth: state.smooth,
      colorScheme: state.colorScheme
    });
  }
}

function render(forceFull) {
  renderQueued = false;
  currentGeneration++;
  pendingTiles = 0;
  tileMap.clear();
  tileResults.clear();

  const draft = !forceFull && (interacting || state.animating);

  if (state.fractalType === 'split') {
    dispatchRender(splitCtx, splitCanvas, 'mandelbrot', 0, 0, draft);
    dispatchRender(ctx, canvas, 'julia', state.c.real, state.c.imag, draft);
  } else {
    dispatchRender(ctx, canvas, state.fractalType, state.c.real, state.c.imag, draft);
  }

  updateOverlays();
}

function queueRender() {
  if (!renderQueued) {
    renderQueued = true;
    requestAnimationFrame(() => render(false));
  }
}

function scheduleFullRender() {
  if (fullResTimeout) clearTimeout(fullResTimeout);
  fullResTimeout = setTimeout(() => {
    interacting = false;
    renderQueued = true;
    requestAnimationFrame(() => render(true));
  }, 200);
}

function interactiveRender() {
  interacting = true;
  queueRender();
  scheduleFullRender();
}

// ==================== OVERLAYS ====================
function updateOverlays() {
  document.getElementById('zoom-overlay').textContent = `Zoom: ${state.zoom.toFixed(2)}x`;
}

// ==================== ORBIT VISUALIZATION ====================
function showOrbit(px, py) {
  if (!state.showOrbit) return;

  const w = canvas.width;
  const h = canvas.height;
  const p = pixelToComplex(px, py, w, h, state.centerX, state.centerY, state.zoom);

  let zr, zi, cr, ci;
  if (state.fractalType === 'julia' || state.fractalType === 'split') {
    zr = p.x; zi = p.y;
    cr = state.c.real; ci = state.c.imag;
  } else {
    zr = 0; zi = 0;
    cr = p.x; ci = p.y;
  }

  const orbit = [{ r: zr, i: zi }];
  const escR2 = state.escapeRadius * state.escapeRadius;
  let i = 0;
  while (i < state.maxIter && zr * zr + zi * zi <= escR2) {
    const tmp = zr * zr - zi * zi + cr;
    zi = 2 * zr * zi + ci;
    zr = tmp;
    orbit.push({ r: zr, i: zi });
    i++;
    if (orbit.length > 200) break;
  }

  const panel = document.getElementById('orbit-panel');
  panel.classList.add('visible');
  panel.innerHTML = `
    <strong>Orbit Analysis</strong><br>
    z₀ = ${p.x.toFixed(4)} + ${p.y.toFixed(4)}i<br>
    Iterations: ${i} / ${state.maxIter}<br>
    Final |z|: ${Math.sqrt(zr * zr + zi * zi).toFixed(4)}<br>
    <span style="color:var(--text-dim)">${i >= state.maxIter ? 'In set (bounded)' : 'Escaped'}</span>
  `;

  // Draw orbit on canvas
  render();
  ctx.strokeStyle = 'rgba(255,255,255,0.6)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  const scale = 3 / (Math.min(w, h) * state.zoom);
  for (let j = 0; j < orbit.length; j++) {
    const sx = (orbit[j].r - state.centerX) / scale + w / 2;
    const sy = (orbit[j].i - state.centerY) / scale + h / 2;
    if (j === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
  }
  ctx.stroke();

  // Draw points
  ctx.fillStyle = 'rgba(233, 69, 96, 0.8)';
  for (let j = 0; j < Math.min(orbit.length, 100); j++) {
    const sx = (orbit[j].r - state.centerX) / scale + w / 2;
    const sy = (orbit[j].i - state.centerY) / scale + h / 2;
    ctx.beginPath();
    ctx.arc(sx, sy, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ==================== ANIMATION ====================
let animFrame = null;

function animStep(timestamp) {
  if (!state.animating) return;

  state.animT += state.animSpeed * 0.002;
  if (state.animT > 1) state.animT -= 1;

  if (state.animPath === 'circle') {
    state.c.real = 0.7885 * Math.cos(2 * Math.PI * state.animT);
    state.c.imag = 0.7885 * Math.sin(2 * Math.PI * state.animT);
  } else {
    // Figure-8 (lemniscate)
    const t = 2 * Math.PI * state.animT;
    const denom = 1 + Math.sin(t) * Math.sin(t);
    state.c.real = 0.7 * Math.cos(t) / denom;
    state.c.imag = 0.7 * Math.sin(t) * Math.cos(t) / denom;
  }

  updateSliders();
  render();
  animFrame = requestAnimationFrame(animStep);
}

function startAnim() {
  state.animating = true;
  animFrame = requestAnimationFrame(animStep);
}

function pauseAnim() {
  state.animating = false;
  if (animFrame) cancelAnimationFrame(animFrame);
  // Render full quality when animation stops
  renderQueued = true;
  requestAnimationFrame(() => render(true));
}

function stopAnim() {
  pauseAnim();
  state.animT = 0;
}

// ==================== UI BINDINGS ====================
function updateSliders() {
  document.getElementById('real-slider').value = state.c.real;
  document.getElementById('imag-slider').value = state.c.imag;
  document.getElementById('real-val').textContent = state.c.real.toFixed(4);
  document.getElementById('imag-val').textContent = state.c.imag.toFixed(4);
}

// Fractal type
document.querySelectorAll('input[name="fractalType"]').forEach(r => {
  r.addEventListener('change', () => {
    state.fractalType = r.value;
    const showJulia = r.value === 'julia' || r.value === 'split';
    document.getElementById('julia-params').style.display = showJulia ? '' : 'none';
    document.getElementById('presets-section').style.display = showJulia ? '' : 'none';
    document.getElementById('anim-section').style.display = showJulia ? '' : 'none';
    resizeCanvas();
  });
});

// Sliders
document.getElementById('real-slider').addEventListener('input', e => {
  state.c.real = parseFloat(e.target.value);
  document.getElementById('real-val').textContent = state.c.real.toFixed(4);
  interactiveRender();
});

document.getElementById('imag-slider').addEventListener('input', e => {
  state.c.imag = parseFloat(e.target.value);
  document.getElementById('imag-val').textContent = state.c.imag.toFixed(4);
  interactiveRender();
});

document.getElementById('iter-slider').addEventListener('input', e => {
  state.maxIter = parseInt(e.target.value);
  document.getElementById('iter-val').textContent = state.maxIter;
  interactiveRender();
});

document.getElementById('escape-slider').addEventListener('input', e => {
  state.escapeRadius = parseFloat(e.target.value);
  document.getElementById('escape-val').textContent = state.escapeRadius;
  interactiveRender();
});

document.getElementById('smooth-check').addEventListener('change', e => {
  state.smooth = e.target.checked;
  queueRender();
});

document.getElementById('color-scheme').addEventListener('change', e => {
  state.colorScheme = e.target.value;
  queueRender();
});

// Presets
document.querySelectorAll('.preset-btn[data-real]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.c.real = parseFloat(btn.dataset.real);
    state.c.imag = parseFloat(btn.dataset.imag);
    updateSliders();
    queueRender();
  });
});

document.getElementById('random-preset').addEventListener('click', () => {
  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
  state.c.real = (Math.random() - 0.5) * 2.5;
  state.c.imag = (Math.random() - 0.5) * 2.5;
  updateSliders();
  queueRender();
});

// View controls
document.getElementById('zoom-in-btn').addEventListener('click', () => { state.zoom *= 1.5; interactiveRender(); });
document.getElementById('zoom-out-btn').addEventListener('click', () => { state.zoom /= 1.5; interactiveRender(); });
document.getElementById('reset-view-btn').addEventListener('click', resetView);

function resetView() {
  state.centerX = 0;
  state.centerY = 0;
  state.zoom = 1;
  queueRender();
}

// Show coords
document.getElementById('show-coords').addEventListener('change', e => {
  state.showCoords = e.target.checked;
  document.getElementById('coords-overlay').style.display = e.target.checked ? '' : 'none';
});

document.getElementById('show-orbit').addEventListener('change', e => {
  state.showOrbit = e.target.checked;
  if (!e.target.checked) {
    document.getElementById('orbit-panel').classList.remove('visible');
    queueRender();
  }
});

// Animation
document.getElementById('anim-play').addEventListener('click', startAnim);
document.getElementById('anim-pause').addEventListener('click', pauseAnim);
document.getElementById('anim-stop').addEventListener('click', stopAnim);

document.getElementById('speed-slider').addEventListener('input', e => {
  state.animSpeed = parseFloat(e.target.value);
  document.getElementById('speed-val').textContent = state.animSpeed.toFixed(2);
});

document.querySelectorAll('input[name="animPath"]').forEach(r => {
  r.addEventListener('change', () => { state.animPath = r.value; });
});

// Toggle controls
document.getElementById('toggle-controls').addEventListener('click', toggleControls);

function toggleControls() {
  state.controlsVisible = !state.controlsVisible;
  document.getElementById('controls').classList.toggle('collapsed', !state.controlsVisible);
  setTimeout(resizeCanvas, 310);
}

// Quiz button
document.getElementById('quiz-btn').addEventListener('click', startQuiz);

// Info panel
document.getElementById('info-btn').addEventListener('click', () => {
  document.getElementById('info-panel').classList.toggle('visible');
});
document.getElementById('close-info').addEventListener('click', () => {
  document.getElementById('info-panel').classList.remove('visible');
});

// Export
document.getElementById('save-btn').addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = `julia-set-${state.c.real.toFixed(3)}_${state.c.imag.toFixed(3)}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
});

document.getElementById('copy-params-btn').addEventListener('click', () => {
  const params = `c = ${state.c.real} + ${state.c.imag}i | Zoom: ${state.zoom.toFixed(2)}x | Iterations: ${state.maxIter} | Color: ${state.colorScheme}`;
  navigator.clipboard.writeText(params).then(() => {
    const btn = document.getElementById('copy-params-btn');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy Parameters', 1500);
  });
});

// ==================== MOUSE INTERACTION ====================
const container = document.getElementById('canvas-container');
let dragRenderTimeout = null;

container.addEventListener('mousemove', e => {
  if (state.showCoords && !state.dragging) {
    const rect = canvas.getBoundingClientRect();
    const dpr = canvas.width / rect.width;
    const px = (e.clientX - rect.left) * dpr;
    const py = (e.clientY - rect.top) * dpr;
    const p = pixelToComplex(px, py, canvas.width, canvas.height, state.centerX, state.centerY, state.zoom);
    document.getElementById('coords-overlay').textContent =
      `${p.x >= 0 ? ' ' : ''}${p.x.toFixed(6)} ${p.y >= 0 ? '+' : '-'} ${Math.abs(p.y).toFixed(6)}i`;
  }

  if (state.dragging) {
    const dx = e.clientX - state.dragStartX;
    const dy = e.clientY - state.dragStartY;

    // Update center based on drag delta
    const rect = canvas.getBoundingClientRect();
    const dpr = canvas.width / rect.width;
    const scale = 3 / (Math.min(canvas.width, canvas.height) * state.zoom);
    state.centerX = state.dragCenterX - dx * dpr * scale;
    state.centerY = state.dragCenterY - dy * dpr * scale;

    // Live draft render during drag
    interactiveRender();
  }
});

container.addEventListener('mousedown', e => {
  if (e.button === 0) {
    state.dragging = true;
    state.dragStartX = e.clientX;
    state.dragStartY = e.clientY;
    state.dragCenterX = state.centerX;
    state.dragCenterY = state.centerY;
    container.style.cursor = 'grabbing';
    if (dragRenderTimeout) clearTimeout(dragRenderTimeout);
  }
});

window.addEventListener('mouseup', () => {
  if (state.dragging) {
    state.dragging = false;
    container.style.cursor = 'crosshair';
    scheduleFullRender();
  }
});

container.addEventListener('click', e => {
  if (state.showOrbit && !state.dragging) {
    const rect = canvas.getBoundingClientRect();
    const dpr = canvas.width / rect.width;
    const px = (e.clientX - rect.left) * dpr;
    const py = (e.clientY - rect.top) * dpr;
    showOrbit(px, py);
  }

  // Split view: click on mandelbrot side sets julia c value
  if (state.fractalType === 'split') {
    const rect = splitCanvas.getBoundingClientRect();
    if (e.clientX >= rect.left && e.clientX <= rect.right) {
      const dpr = splitCanvas.width / rect.width;
      const px = (e.clientX - rect.left) * dpr;
      const py = (e.clientY - rect.top) * dpr;
      const p = pixelToComplex(px, py, splitCanvas.width, splitCanvas.height, state.centerX, state.centerY, state.zoom);
      state.c.real = p.x;
      state.c.imag = p.y;
      updateSliders();
      queueRender();
    }
  }
});

container.addEventListener('dblclick', e => {
  const rect = canvas.getBoundingClientRect();
  const dpr = canvas.width / rect.width;
  const px = (e.clientX - rect.left) * dpr;
  const py = (e.clientY - rect.top) * dpr;
  const p = pixelToComplex(px, py, canvas.width, canvas.height, state.centerX, state.centerY, state.zoom);
  state.centerX = p.x;
  state.centerY = p.y;
  state.zoom *= 2;
  queueRender();
});

container.addEventListener('wheel', e => {
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;

  // Zoom toward mouse position
  const rect = canvas.getBoundingClientRect();
  const dpr = canvas.width / rect.width;
  const px = (e.clientX - rect.left) * dpr;
  const py = (e.clientY - rect.top) * dpr;
  const p = pixelToComplex(px, py, canvas.width, canvas.height, state.centerX, state.centerY, state.zoom);

  state.zoom *= factor;

  // Adjust center so mouse position stays fixed
  const newP = pixelToComplex(px, py, canvas.width, canvas.height, state.centerX, state.centerY, state.zoom);
  state.centerX += p.x - newP.x;
  state.centerY += p.y - newP.y;

  interactiveRender();
}, { passive: false });

// ==================== KEYBOARD SHORTCUTS ====================
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

  switch (e.key) {
    case ' ': e.preventDefault(); toggleControls(); break;
    case 'r': case 'R': resetView(); break;
    case 's': case 'S': document.getElementById('save-btn').click(); break;
    case 'a': case 'A': state.animating ? pauseAnim() : startAnim(); break;
    case 'i': case 'I': document.getElementById('info-panel').classList.toggle('visible'); break;
    case '+': case '=': state.zoom *= 1.5; interactiveRender(); break;
    case '-': case '_': state.zoom /= 1.5; interactiveRender(); break;
    case 'ArrowUp': state.centerY -= 0.1 / state.zoom; interactiveRender(); break;
    case 'ArrowDown': state.centerY += 0.1 / state.zoom; interactiveRender(); break;
    case 'ArrowLeft': state.centerX -= 0.1 / state.zoom; interactiveRender(); break;
    case 'ArrowRight': state.centerX += 0.1 / state.zoom; interactiveRender(); break;
    case '1': selectPreset(0); break;
    case '2': selectPreset(1); break;
    case '3': selectPreset(2); break;
    case '4': selectPreset(3); break;
    case '5': selectPreset(4); break;
    case '6': selectPreset(5); break;
  }
});

function selectPreset(idx) {
  const btns = document.querySelectorAll('.preset-btn[data-real]');
  if (btns[idx]) btns[idx].click();
}

// ==================== INIT ====================
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
</script>
</body>
</html>
